# ------------------------------------------------------------------------------
# Run Numbat
# ------------------------------------------------------------------------------

log <- file(snakemake@log[[1]], open="wt")
sink(log)
sink(log, type="message")

# ------------------------------------------------------------------------------
print("Load libraries")
# ------------------------------------------------------------------------------

library(numbat)
library(data.table)

# ------------------------------------------------------------------------------
print("Get input parameters from snakemake")
# ------------------------------------------------------------------------------

input_count_mat <- snakemake@input$count_mat
input_annotations<-snakemake@input$annot
input_ref_groups<-snakemake@input$ref_groups
input_allele_path <- snakemake@input$df_allele

#Set gamma value based on technologs (20 for 10X, 5 for Smart-seq2)
input_gamma<-snakemake@params$gamma
if(is.null(input_gamma)){
  input_gamma<-20
} else {
  input_gamma<-as.numeric(input_gamma)
}
print(paste("Running Numbat with the following gamma cutoff",input_gamma))

#Set LLR value (can be lowered in case no CNVs are found)
input_min_LLR<-snakemake@params$min_LLR
if(is.null(input_min_LLR)){
  input_min_LLR<-5
} else {
  input_min_LLR<-as.numeric(input_min_LLR)
}
print(paste("Running Numbat with the following min LLR threshold",input_min_LLR))

#Set minimal number of cells (the smaller datasets don't have even 50 cells)
input_min_cells<-snakemake@params$min_cells
if(is.null(input_min_cells)){
  input_min_cells<-20
} else {
  input_min_cells<-as.numeric(input_min_cells)
}
print(paste("Running Numbat with the following min_cells threshold:",input_min_cells))

out_cnv_expr <- snakemake@output$cnv_expr

threads<-snakemake@threads

# ------------------------------------------------------------------------------
print("Execute Numbat")
# ------------------------------------------------------------------------------

#Load dataset matrix (annotation file not required in this modus)
data_matrix<-fread(input_count_mat)
#Format into a matrix
gene_names<-data_matrix$V1
data_matrix$V1<-NULL
data_matrix<-as.matrix(data_matrix)
rownames(data_matrix)<-gene_names

#Extract reference cells
annotation<-fread(input_annotations, header=FALSE)
ref_groups<-read.table(input_ref_groups,header=TRUE)
ref_cells <- annotation$V1[annotation$V2 %in% ref_groups$ref_groups]
cancer_cells<-annotation$V1[!annotation$V2 %in% ref_groups$ref_groups]

#Split into cancer and reference matrix
count_matrix<-data_matrix[,cancer_cells]
ref_matrix<-data_matrix[,ref_cells]

#Reformat reference matrix according to numbat standards
ref_annotations<-annotation[annotation$V2 %in% ref_groups$ref_groups,]
colnames(ref_annotations)<-c("cell","group")
ref_internal <- aggregate_counts(ref_matrix, ref_annotations)

#Read input AF file
df_allele<-fread(input_allele_path)

out = run_numbat(
  count_matrix, # gene x cell integer UMI count matrix 
  ref_internal, # reference expression profile, a gene x cell type normalized expression level matrix
  df_allele, # allele dataframe generated by pileup_and_phase script
  genome = "hg38",
  t = 1e-5,
  ncores = threads,
  plot = TRUE,
  out_dir = dirname(out_cnv_expr),
  gamma = input_gamma, #For 10X: 20, for Smartseq 5 (dispersion parameter for allele model)
  min_LLR = input_min_LLR,
  min_cells = input_min_cells
)

# ------------------------------------------------------------------------------
print("SessionInfo:")
# ------------------------------------------------------------------------------
sessionInfo()
