# ------------------------------------------------------------------------------
# Extract CaSpER heatmap
# ------------------------------------------------------------------------------

log <- file(snakemake@log[[1]], open="wt")
sink(log)
sink(log, type="message")

# ------------------------------------------------------------------------------
print("Load libraries")
# ------------------------------------------------------------------------------

library(CaSpER)
library(data.table)

# ------------------------------------------------------------------------------
print("Get input parameters from snakemake")
# ------------------------------------------------------------------------------

input_casper_object <- snakemake@input$casper_object
input_annotations<-snakemake@input$annot
input_ref_groups<-snakemake@input$ref_groups
input_gene_annot<-snakemake@input$gene_annot

input_annot_truth<-snakemake@input$annot_truth 
input_segment_gamma <- as.numeric(snakemake@params$segment_gamma)

output_hclust <- snakemake@output$hclust
output_clustering <- snakemake@output$clustering
output_clones_pbulk <- snakemake@output$clones_pbulk

# ------------------------------------------------------------------------------
print("Recalculate the clusterings generated by Casper")
# ------------------------------------------------------------------------------

final.objects <- readRDS(file=input_casper_object)

cnv.scale <- 3
obj <- final.objects[[9]]

data <- obj@control.normalized.noiseRemoved[[cnv.scale]]
x.center <- mean(data)
quantiles = quantile(data[data != x.center], c(0.01, 0.99))
delta = max(abs(c(x.center - quantiles[1], quantiles[2] - 
                    x.center)))
low_threshold = x.center - delta
high_threshold = x.center + delta
x.range = c(low_threshold, high_threshold)
data[data < low_threshold] <- low_threshold
data[data > high_threshold] <- high_threshold
breaks <- seq(x.range[1], x.range[2], length = 16)
color <- colorRampPalette(rev(brewer.pal(11, "RdYlBu")))(length(breaks))
idx <- cumsum(table(obj@annotation.filt$Chr)[as.character(1:22)])
xlabel <- rep("", length(rownames(obj@data)))
half <- round(table(obj@annotation.filt$Chr)[as.character(1:22)]/2)[-1]
xpos <- c(half[1], (idx[-22] + half))
xlabel[xpos] <- 1:22

data <- data[, !(colnames(data) %in% obj@control.sample.ids)]

clusters<-hclust(dist(t(data), "euclidean"), method="complete")

saveRDS(clusters,file=output_hclust)

# ------------------------------------------------------------------------------
print("Calculate clustering results per subclone")
# ------------------------------------------------------------------------------

segment.summary <- extractSegmentSummary(final.objects)
loss <- segment.summary$all.summary.loss
gain <- segment.summary$all.summary.gain
#loh <- segment.summary$all.summary.loh #ignore loss of heterozygosity for the moment

loss.final <- loss[loss$count>=input_segment_gamma, ]
gain.final <- gain[gain$count>=input_segment_gamma, ]
segments<-rbind(loss.final,gain.final)

#Load metadata and ref groups
meta_data <- fread(input_annotations,header=FALSE)
colnames(meta_data)<-c("cell","sample")
ref_groups<-read.table(input_ref_groups,header=TRUE)

#Filter the segments for the cancer cells and create a Grange
cancer_cells <- meta_data$cell[!(meta_data$sample %in% ref_groups$ref_groups)]
cancer_cells <- intersect(cancer_cells,segments$ID)
segments <- segments[segments$ID %in% cancer_cells,]
seg_grange <-  GRanges(seqnames = Rle(paste0("chr",gsub("p|q", "", segments$seqnames))), 
                       IRanges(segments$start, segments$end)) 

#Read gene annotation
annotation<-read.table(input_gene_annot,
                       header=TRUE,stringsAsFactors = FALSE)

#Create a Grange from the gene annotations
annotation$Chr<-paste0("chr",annotation$Chr)
ann_gr <- makeGRangesFromDataFrame(annotation, 
                                   keep.extra.columns = TRUE, seqnames.field="Chr")

#Get gene-wise CNV annotations following the code from the CaSpER tutorial
genes <- splitByOverlap(ann_gr, seg_grange, "GeneSymbol")
genes_ann <- lapply(genes, function(x) x[!(x=="")])
rna_matrix <- gene.matrix(seg=segments, all.genes=unique(annotation$GeneSymbol), 
                          all.samples=cancer_cells, 
                          genes.ann=genes_ann)

#Define distinct subclones (based number of ground truth samples)
ground_truth<-fread(input_annot_truth)
param_splitted_clusters<-length(unique(ground_truth$cluster))
groups_casper<-cutree(clusters,k=param_splitted_clusters)
clustering_casper<-data.frame(cell=names(groups_casper),
                              casper=groups_casper)

#Filter cells
common_cells<-intersect(colnames(rna_matrix),clustering_casper$cell)
rna_matrix<-rna_matrix[,common_cells]
clustering_casper<-clustering_casper[common_cells,]

#Calculate pseudotime groups
clustering_casper$casper<-as.factor(clustering_casper$casper)
cnv_per_clone<-t(apply(rna_matrix,1,tapply,clustering_casper$casper,mean))+2
colnames(cnv_per_clone)<-paste0("casper_",colnames(cnv_per_clone))
#all(ann_gr$Gene == rownames(cnv_per_clone))
mcols(ann_gr)<-cnv_per_clone

#Save final clustering and pseuodbulk
write.table(clustering_casper,quote=FALSE, sep="\t",row.names=FALSE,
            file=output_clustering)
write.table(ann_gr,quote=FALSE, sep="\t",row.names=FALSE,
            file=output_clones_pbulk)

# ------------------------------------------------------------------------------
print("SessionInfo:")
# ------------------------------------------------------------------------------
sessionInfo()
